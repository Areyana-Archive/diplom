\section{Используемые технологии}
\label{sec:practice:technology_used}

\subsection{Выбор языка программирования}
Так как было решено решено разработать Android-приложение, разработку необходимо вести на языке, который имеет поддержку для выполнения в среде Android. К таковым можно отнести: Java, Kotlin, C++. Каждый из языков имеет место быть в Android разработке, рассмотрим каждый из них.

Java~-- самый популярный на данный момент язык для Android разработки. Большое сообщество, много библиотек и готовых модулей. Разработчик всегда может рассчитывать на быструю помощь по любому вопросу от сообщества, если он пишет на этом языке.

Плюсы:
\begin{itemize}
 \item большое сообщество готовое помочь;
 \item огромное количество учебных материалов;
 \item множество плагинов для сред разработки упрощяющих жизнь.
\end{itemize}

Минусы:
\begin{itemize}
 \item неоправданно громоздкий код;
 \item в следствии трендов для Android разработки, код на Java постепенно переходит в статус Legacy;
 \item новые библиотеки обходят Java стороной, в основном новые библиотеки пишут на Kotlin.
\end{itemize}
 
Kotlin~-- статически типизированный, объектно-ориентированный язык программирования, работающий поверх Java Virtual Machine и разрабатываемый компанией JetBrains. Также компилируется в JavaScript и в исполняемый код ряда платформ через инфраструктуру LLVM \cite{kotlin1}. С недавнего времени стал одним из предпочитаемых и официальных языков для разработки под Android \cite{web2}.

Плюсы:
\begin{itemize}
 \item полностью совместим с Java;
 \item null safety. По умолчанию в Kotlin переменные не могут принимать null, если вы явно их так не обозначите;
 \item higher-Order Functions, т.е. функции которые принимают функции, как параметры;
 \item в перспективе лучший выбор для Android разработки.
\end{itemize}

Минусы:
\begin{itemize}
 \item зачастую не использует функциональность из старших версий JVM;
 \item присутствуют проблемы с annotation processing;
 \item всё ещё не все плагины для Java адаптированы для Kotlin;
 \item язык молодой, могут присутствовать ошибки.
\end{itemize}

С++ (Android NDK)~-- позволяет писать лишь некоторые части на C++ для обеспечения кроссплатформенности библиотек. Является инструментом для решения локальных проблем и не может рассматриваться как основной язык для написания Android приложений \cite{web12}.

Также рассмотрим другие альтернативы в виде Flutter и React Native, как самые популярные фрейморвки для разработки мобильных приложений.

Flutter~-- SDK с открытым исходным кодом для создания мобильных приложений от компании Google. Он используется для разработки приложений под Android и других платформ.

Плюсы:
\begin{itemize}
 \item кроссплатформенность;
 \item перспективность и активное развитие;
 \item важнейшие библиотеки уже есть, постоянно выходят новые;
 \item собственный графический движок;
 \item интерфейс легко разбивается на отдельные модули.
\end{itemize}

Минусы:
\begin{itemize}
 \item конечный установочный пакет больше, так как в него добавляется виртуальная машина Dart;
 \item интерфейс создается с помощью кода, из-за чего грань между логикой и дизайном гораздо тоньше;
 \item библиотек (и информации) меньше, чем для нативной разработки;
 \item нестабильность (совсем недавно вышел из beta).
\end{itemize}


React Native позволяет создавать мобильные приложения, используя при этом только JavaScript с такой же структурой, что и у React. Это дает возможность составлять многофункциональный мобильный UI с применением декларативных компонентов. Список плюсов и минусов совпадает с Flutter, за исключением собственного графического движка, React Native работает нативно на всех платформах используя их средства.

Фреймворки всегда являлись хорошим выбором для прототипирования за счёт быстроты, универсальности между платформами, однако имеют существенный минус в перспективе. В случае с Flutter~-- язык разработки Dart, а в случае с React Native~-- JavaScript/TypeScript. В конечном итоге у комнады будет 3 языка на которых они пишут для поддержки (по 1 нативному на каждоую мобильную платформу и 1 язык для фреймворка), что влечёт за собой непредвиденные ошибки.

\subsection{Kotlin}
Таким образом был сделан выбор в сторону языка Kotlin. Он является относительно молодым и перспективным языком для Android разработки, который не устареет в ближайшее время и будет получать всё больше поддержки и библиотек. В случае Kotlin, который возник как язык на Java Virtual Machine или JVM, существует дополнительный уровень между компилятором и ОС. Компилятор Kotlin создает так называемый байт-код, который запускается на JVM и попутно преобразуется в собственный код. Kotlin начал с JVM, но теперь можно скомпилировать Kotlin непосредственно в собственный код. Собственно это и создает ту самую полную совместимость с Java. Основным плюсом по отношению к Java является более простой код. Язык позволяет, определяя переменные, поля, константы и прочее, указать, может ли в них храниться ссылка на null. Поднимает на новый уровень идею аннотаций вроде @Nullable и NotNull, позволяет умно приводить к не-nullable типу после проверки её на null. Kotlin позволяет выводить тип переменной на основании данных, которыми переменная инициализируется. Поэтому при инициализации переменной тип можно опустить. Bозможность, которой остро не хватает в Java для увеличения гибкости языка и решений. Заключается в возможности определить метод для типа отдельно от его (типа) объявления. Такая функция, конечно, не будет виртуальной и никак не меняет класса, которому мы добавляем метод, однако позволяет добавить как утилитарную функциональность для уже существующего кода, так и разгрузить интерфейс от этих же утилитарных методов. И у Kotlin функция~-- это сущность первого класса, если переводить дословно. Т.е. функции можно не только объявлять прямо в пакете (из Java они видны всё равно в классах~-- по имени файла), но и передавать в качестве параметров, возвращать из других функций и тд.

\subsection{Построение пользовательского интерфейса}
Далее встаёт вопрос визуализации пользовательского интерфейса. Интерфейс мобильного приложения на Android представляет собой набор XML файлов. 
XML, стили, векторные ресурсы определяют структуру и визуальное оформление содержимого мобильного приложения. Ресурсы являются одним из основных компонентов, с которыми приходится работать очень часто. В Android принято держать изображения, строковые константы, цвета, анимацию и стили за пределами исходного кода. Система поддерживает хранение ресурсов в отдельных файлах. Ресурсы легче поддерживать, обновлять, редактировать. Стандартный путь построения интерфейсов это XML файлы с его описанием, однако относительно недавно в бету вышел Jetpack Compose, что является новым словом в UI для Android. Рассмотрим оба варианта:

Jetpack Compose~-- это современный набор инструментов для создания собственного пользовательского интерфейса в Android-приложении. Этот декларативный фреймворк упрощает и ускоряет разработку пользовательского интерфейса на Android с меньшим количеством кода, мощными инструментами и интуитивно понятными API-интерфейсами Kotlin \cite{web13}.
 
Плюсы:
\begin{itemize}
 \item перспективность и активное развитие;
 \item переиспользование компонентов;
 \item более простая работа с редактором;
 \item пишутся на Kotlin.
\end{itemize}

Минусы:
\begin{itemize}
 \item сырая;
 \item маленькое сообщество;
 \item библиотека всё еще в бета версии;
 \item тесная связь между отображением и бизнес-логикой.
\end{itemize}

XML~-- стандартный и стабильный вариант построения интерфейсов для приложений на Android, интерфейсы описываются в xml файлах, после этого обрабатываются в их фрагментах и активностях.

Плюсы:
\begin{itemize}
 \item стабильность;
 \item большое сообщество;
 \item версии библиотек стабильные;
 \item разделение между представлением и бизнес-логикой.
\end{itemize}

Минусы:
\begin{itemize}
 \item низкая переиспользуемость.
\end{itemize}

Для проекта выберем XML, так как Jetpack Compose при всех его минусах, всё ещё очень сырая, а для перспективы нам нужна более стабильная система интерфейсов.

\subsection{Синхронизация данных}
При разработке мобильного приложения необходимо определиться c технологиями и подходом к методам синхронизации и обмена данными, а также стратегией кеширования, которые доступны для реализации в мобильном приложении. Были рассмотрены следующие варианты: ленивый кеш, синхронизированный кеш и кеш сквозной записи. 
 
В проекте будет реализована локальная SQL (в частности SQLite) база данных для кеширования, серверная NoSQL база данных для сохранения настроек пользователя, а также запросы на сторонние сервисы через интернет.

SQLite~-- компактная встраиваемая СУБД. Слово «встраиваемый» означает, что SQLite не использует парадигму клиент-сервер, то есть движок SQLite не является отдельно работающим процессом, с которым взаимодействует программа, а представляет собой библиотеку, с которой программа компонуется, и движок становится составной частью программы \cite{sqlite1}. Таким образом, в качестве протокола обмена используются вызовы функций (API) библиотеки SQLite. Такой подход уменьшает накладные расходы, время отклика и упрощает программу. SQLite хранит всю базу данных (включая определения, таблицы, индексы и данные) в единственном стандартном файле на том устройстве, на котором исполняется программа. Простота реализации достигается за счёт того, что перед началом исполнения транзакции записи весь файл, хранящий базу данных, блокируется. ACID-функции достигаются в том числе за счёт создания файла журнала.

Несколько процессов или потоков могут одновременно без каких-либо проблем читать данные из одной базы. Запись в базу можно осуществить только в том случае, если никаких других запросов в данный момент не обслуживается. B противном случае попытка записи оканчивается неудачей, и в программу возвращается код ошибки. Другим вариантом развития событий является автоматическое повторение попыток записи в течение заданного интервала времени.

Для того, чтобы упростить разработку приложения, было решено использовать сервис Firebase от компании Google. Данный сервис предлагает множество модулей, которые очень полезны для мобильной разработки. Данный сервис избавляет от нужды в собственном сервере, так как Firebase реализует практически все возможности, которые необходимы от стандартного сервера. Главным инструментом в составе Firebase является их база данных. На данный момент Firebase предлагает несколько различных вариантов баз данных: Realtime Database и Firestore. Их главное отличие заключается в форме хранения данных и доступа к ним. 

Realtime Database использует JSON файлы для хранения информации. Это является крайне неэффективным, так как для получения определённых данных сначала нужно получить все данные из файла, а только потом можно произвести поиск. Это увеличивает потребность приложения в ресурсах системы, что недопустимо для данного проекта. 

Firestore~-- облачная NoSQL база данных реального времени. Это означает то, что, при использовании данной базы данных, пользователь может «подписаться» на определённые документы. В таком случае при изменении содержимого документа пользователь сразу получит новые данные. Благодаря данному механизму можно быть уверенным, что конечный пользователь получит самую свежую информацию. Firestore поддерживает следующие типы данных:

\begin{itemize}
    \item текстовая строка;
    \item числа;
    \item булевые значения;
    \item массивы;
    \item даты;
    \item словари.
\end{itemize}

Для удалённой базы данных будем использовать Firebase/Firestore как дефакто стандарт для Android приложений. Так как Firestore является NoSQL базой данных, то для организации данных в ней используются не таблицы, а документы. Отличие заключается в том, что документ не имеет жёсткой структуры, как таблицы, что позволяет хранить в документах данные произвольных типов и менять их значение и структуру по мере необходимости. Данный способ позволяет более гибко взаимодействовать с данными, но лишает дополнительной надёжности, свойственной SQL базам данных.

Для организации документов используются коллекции. Коллекция~-- это просто набор документов. Они не обязаны быть одинаковыми, но данный случай крайне нежелателен. Каждый документы в коллекции имеет идентификатор, уникальный для данной коллекции. В качестве идентификатора может выступать любая подходящая текстовая строка. Документы также способны содержать внутри себя вложенные коллекции, однако данная возможность не особо полезна. Также имеется возможность создания пользовательских функций и триггеров для взаимодействия с базой данных, что позволяет выполнять определённые операции при изменении, создании или удалении документов и коллекций. 

Firebase также предлагает встроенную систему аутентификации пользователей, которая поддерживает различные источники для идентификации: почта, профиль Google и др.

Также плюсом Firebase является возможность его интеграции с другими сервисами компании Google и защита от прекращения работы сервера.

\subsection{Недостатки Firebase}
Основные возможности, которые предоставляет Firebase связанные с хранением, изменением и получением информации из встроенной базы данных. Firebase не имеет возможности для создания API, поэтому для решения вспомогательных задач, не связанных с базой данных необходим дополнительный API-cервер, который будет заниматься обработкой запросов и обращаться к Firestore по мере необходимости.

Теперь рассмотрим стратегии локального кеширования:

Ленивый кеш~-- самый простой вид кеширования, но его нужно использовать осторожно, так как отдает устаревшие данные. Можно при каждой записи сбрасывать ленивый кеш, чтобы поддерживать актуальность данных, но тогда затраты на реализацию будут сравнимы с более сложными типами кеширования \cite{web15}.

Такой тип кеширования можно использовать для данных, которые почти никогда не меняются. Другой вариант использования~-- делать ленивый кеш с небольшим временем устаревания для стабильной работы при всплесках нагрузки.

Такой тип кеширования позволит быстрее всех дать ответ.

Синхронизированный кеш~-- самый полезный тип кеширования, так как отдает свежие данные и позволяет реализовать многоуровневый кеш.

Такой тип кеширования встроен в протокол HTTP. Сервер отдает метку изменения, а клиент кеширует у тебя результат и в последующем запросе передает эту метку. Сервер может дать ответ, что состояние не изменилось и можно использовать кешированный на клиенте объект. Сервер в свою очередь, получив метку может переспросить у хранилища были ли изменения или нет.

Этот тип кеширования не избавляет от накладных расходов на общение между системами. Поэтому часто дополняется другими типами кеширования, чтобы ускорить работу.

Кеш сквозной записи~-- если есть система распределенного кеширования (memcached, Windows Sever App Fabric, Azure Cache), то можно использовать кеш сквозной записи. Рукопашная реализация синхронизации кешей между узлами сама по себе отдельный большой проект, потому не стоит заниматься ей в рамках разработки приложения.

Не стоит пытаться кешировать все в синхронизированном кеше, иначе большая часть кода приложения будет заниматься перестройкой кеша.

В приложении будет использоваться ленивый кеш для данных.