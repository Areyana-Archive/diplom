% Зачем: Изменение надписи для списка литературы
% Почему: Пункт 2.8.1 Требований по оформлению пояснительной записки.
\renewcommand{\bibsection}{\sectioncentered*{Cписок использованных источников}}
\phantomsection\pagebreak% исправляет нумерацию в документе и исправляет гиперссылки в pdf
\addcontentsline{toc}{section}{Cписок использованных источников}

% Зачем: Печать списка литературы. База данных литературы - файл bibliography_database.bib
\bibliography{bibliography_database}

\newpage
\phantomsection
\addcontentsline{toc}{section}{Приложение А Работа с Firebase}

\begin{center}
    \textbf{\MakeUppercase{Приложение А}\\
    Работа с Firebase}
\end{center}

\begin{lstlisting}[language=Java,label={lst:add:firebase}]
class AuthGatewayImpl : AuthGateway {

    private val auth = FirebaseAuth.getInstance()
    private val storage = FirebaseStorage.getInstance()
    private val db = FirebaseFirestore.getInstance()

    override fun isLoggedIn(): Boolean {
        return auth.currentUser != null
    }

    override suspend fun getUserId(): String {
        val user = auth.currentUser!!
        return user.uid
    }

    override fun getAccountData(): Pair<String, String> {
        val user = auth.currentUser!!
        return (user.displayName ?: "No Name") to (user.email ?: "No Email")
    }

    override suspend fun signUp(email: String, password: String, name: String) {
        return suspendCoroutine { cont ->
            auth.createUserWithEmailAndPassword(email, password)
                .addOnCompleteListener {
                    if (it.isSuccessful) {
                        auth.currentUser?.updateProfile(
                            UserProfileChangeRequest.Builder().setDisplayName(name).build()
                        )
                        cont.resume(Unit)
                    } else {
                        cont.resumeWithException(Exception(if (it.exception != null) it.exception!!.message else "Wrong login or password"))
                    }
                }
        }
    }

    override suspend fun signIn(email: String, password: String) {
        return suspendCoroutine { cont ->
            auth.signInWithEmailAndPassword(email, password)
                .addOnCompleteListener {
                    if (it.isSuccessful) {
                        cont.resume(Unit)
                    } else {
                        cont.resumeWithException(Exception("Wrong login or password"))
                    }
                }
        }
    }

    override suspend fun resetPassword(email: String) {
        return suspendCoroutine { cont ->
            auth.sendPasswordResetEmail(email)
                .addOnCompleteListener {
                    if (it.isSuccessful) {
                        cont.resume(Unit)
                    } else {
                        cont.resumeWithException(Exception("Something went wrong"))
                    }
                }
        }
    }

    override fun signOut() {
        auth.signOut()
    }

    private val avatarFileName = "avatar.jpg"

    override suspend fun postAvatar(uri: Uri) {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val userAvatarRef = storage.reference
                .child("users")
                .child(uid)
                .child(avatarFileName)
            userAvatarRef.putFile(uri)
                .addOnCompleteListener { result ->
                    if (result.isSuccessful) {
                        cont.resume(Unit)
                    } else {
                        cont.resumeWithException(Exception("Something went wrong"))
                    }
                }
        }
    }

    override suspend fun deleteAvatar() {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val userAvatarRef = storage.reference
                .child("users")
                .child(uid)
                .child(avatarFileName)
            userAvatarRef.delete()
                .addOnCompleteListener { result ->
                    if (result.isSuccessful) {
                        cont.resume(Unit)
                    } else {
                        cont.resumeWithException(Exception("Something went wrong"))
                    }
                }
        }
    }

    val usersKey: String = "users"
    val nightModeKey: String = "nightMode"
    val notificationsKey: String = "notifications"
    val storesKey: String = "stores"
    val languageKey: String = "language"

    override suspend fun putNightMode(boolean: Boolean) {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            val map: Map<String, Boolean> = mapOf(nightModeKey to boolean)
            users.set(map, SetOptions.merge()).addOnCompleteListener {
                cont.resume(Unit)
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun getNightMode(): Boolean {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            users.get().addOnCompleteListener {
                if (it.isSuccessful && it.result != null) {
                    val result = it.result!!
                    if (result.contains(nightModeKey)) {
                        cont.resume(result[nightModeKey] as Boolean)
                    } else {
                        cont.resume(false)
                    }
                } else {
                    cont.resumeWithException(Exception("No Connection"))
                }
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun putNotification(boolean: Boolean) {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            val map: Map<String, Boolean> = mapOf(notificationsKey to boolean)
            users.set(map, SetOptions.merge()).addOnCompleteListener {
                cont.resume(Unit)
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun getNotification(): Boolean {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            users.get().addOnCompleteListener {
                if (it.isSuccessful && it.result != null) {
                    val result = it.result!!
                    if (result.contains(notificationsKey)) {
                        cont.resume(result[notificationsKey] as Boolean)
                    } else {
                        cont.resume(false)
                    }
                } else {
                    cont.resumeWithException(Exception("No Connection"))
                }
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun putStores(boolean: Boolean) {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            val map: Map<String, Boolean> = mapOf(storesKey to boolean)
            users.set(map, SetOptions.merge()).addOnCompleteListener {
                cont.resume(Unit)
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun getStores(): Boolean {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            users.get().addOnCompleteListener {
                if (it.isSuccessful && it.result != null) {
                    val result = it.result!!
                    if (result.contains(storesKey)) {
                        cont.resume(result[storesKey] as Boolean)
                    } else {
                        cont.resume(false)
                    }
                } else {
                    cont.resumeWithException(Exception("No Connection"))
                }
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun getLanguage(): String {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            users.get().addOnCompleteListener {
                if (it.isSuccessful && it.result != null) {
                    val result = it.result!!
                    if (result.contains(languageKey)) {
                        cont.resume(result[languageKey] as String)
                    } else {
                        cont.resume("en")
                    }
                } else {
                    cont.resumeWithException(Exception("No Connection"))
                }
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun putLanguage(language: String) {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val users = db.collection(usersKey).document(uid)
            val map: Map<String, String> = mapOf(languageKey to language)
            users.set(map, SetOptions.merge()).addOnCompleteListener {
                cont.resume(Unit)
            }.addOnCanceledListener {
                cont.resumeWithException(Exception("No Connection"))
            }
        }
    }

    override suspend fun getAvatar(): Uri? {
        return suspendCoroutine { cont ->
            val uid = auth.currentUser?.uid!!
            val userAvatarRef = storage.reference
                .child("users")
                .child(uid)
                .child(avatarFileName)
            userAvatarRef.downloadUrl
                .addOnCompleteListener { result ->
                    if (result.isSuccessful) {
                        cont.resume(result.result)
                    } else {
                        cont.resume(null)
                    }
                }
        }
    }
}
\end{lstlisting}
