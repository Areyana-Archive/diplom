% Зачем: Изменение надписи для списка литературы
% Почему: Пункт 2.8.1 Требований по оформлению пояснительной записки.
\renewcommand{\bibsection}{\sectioncentered*{Cписок использованных источников}}
\phantomsection\pagebreak% исправляет нумерацию в документе и исправляет гиперссылки в pdf
\addcontentsline{toc}{section}{Cписок использованных источников}

% Зачем: Печать списка литературы. База данных литературы - файл bibliography_database.bib
\bibliography{bibliography_database}

\newpage
\phantomsection
\addcontentsline{toc}{section}{Приложение А Текст программы}

%\begin{center}
%    \textbf{\MakeUppercase{Приложение А}\\
%    Текст программы}
%\end{center}
%
%\begin{lstlisting}[language=JavaScript,label={lst:add:player}]
%    import React, { Component } from 'react';
%    import { MdPlayArrow, MdPause, MdFullscreen, MdQueue } from 'react-icons/md';
%    import './player.scss';
%    import TimeIndicator from './TimeIndicator';
%    import RangeBar from './Slider';
%    import Hotkeys from 'react-hot-keys';
%    import VolumeSlider from './VolumeSlider';
%    import { PlayerBackend } from '../PlayerBackend/default';
%    import PlayList from './PlayList';
%    import Notifications from './Notifications';
%    import Chat from './Chat';
%     
%    const pauseIcon = <MdPause />;
%    const playIcon = <MdPlayArrow />;
%     
%    class Player extends Component {
%       constructor(props) {
%           super(props);
%           this.processor = new PlayerBackend();
%           this.playerElemetn = React.createRef();
%           this.state = {
%               isFullscreen: false,
%               playbackIcon: playIcon,
%               playbackState: false,
%               playlist: false,
%               showVideoChooser: false,
%               showChat: false,
%           }
%       }
%     
%       componentDidMount() {
%           this.vid_title = document.getElementById('video-title');
%           this._connectToPlayerBackend();
%           document.onfullscreenchange = () => this.setState({ isFullscreen: !this.state.isFullscreen });
%           if (this.props.externalSetUp) {
%               for (const func of this.props.externalSetUp) {
%                   func(this.processor);
%               }
%           }
%       }
%     
%       _connectToPlayerBackend = () => {
%           this.processor.video = document.getElementById('video-player');
%           this.setState({ time: this.processor.time, volume: this.processor.volume })
%     
%           this.processor.video.addEventListener('timeupdate', () => this.setState({ time: this.processor.time }));
%           this.processor.video.addEventListener('volumechange', () => this.setState({ volume: this.processor.volume }));
%     
%           for (const event in this.props.events) {
%               this.processor.addPreAction(this.props.events[event], event);
%           }
%       }
%     
%       playback = () => {
%           this.processor.dispatch('changePlayback', this.processor.paused);
%           this.processor.dispatch('setTime', this.processor.time);
%           let newIcon = this.processor.paused ? pauseIcon : playIcon;
%           this.setState({ playbackIcon: newIcon, playbackState: this.processor.paused });
%       }
%     
%       fullscreen = () => {
%           if (this.state.isFullscreen) {
%               this.leaveFullscreen();
%           } else {
%               this.enterFullscreen();
%           }
%       }
%     
%       enterFullscreen = () => {
%           const elem = this.playerElemetn.current;
%           if (elem.requestFullscreen) {
%               elem.requestFullscreen();
%           } else if (elem.mozRequestFullScreen) {
%               elem.mozRequestFullScreen();
%           } else if (elem.webkitRequestFullscreen) {
%               elem.webkitRequestFullscreen();
%           } else if (elem.msRequestFullscreen) {
%               elem.msRequestFullscreen();
%           }
%       }
%     
%       leaveFullscreen = () => {
%           if (document.exitFullscreen) {
%               document.exitFullscreen();
%           } else if (document.mozCancelFullScreen) {
%               document.mozCancelFullScreen();
%           } else if (document.webkitExitFullscreen) {
%               document.webkitExitFullscreen();
%           } else if (document.msExitFullscreen) {
%               document.msExitFullscreen();
%           }
%       }
%     
%       setTime = (timeValue) => {
%           if (!timeValue.isNaN) {
%               this.processor.dispatch('setTime', timeValue * this.processor.duration);
%           }
%       }
%     
%       setVolume = (volumeValue) => {
%           this.processor.dispatch('setVolume', volumeValue);
%       }
%     
%       changeMute = () => {
%           this.processor.dispatch('changeMute');
%       }
%     
%     
%       togglePlaylist = () => {
%           this.setState({ playlist: !this.state.playlist });
%       }
%     
%       toogleChat = (e) => {
%           this.setState({ showChat: !this.state.showChat });
%       }
%     
%       render() {
%           return (
%               <div className='player-wrapper' id='player' ref={this.playerElemetn}>
%                   <Hotkeys keyName='space' onKeyUp={this.playback} />
%                   <Hotkeys keyName='c' onKeyUp={this.toogleChat} />
%                   <div className='player-layer'>
%                       <video id='video-player' />
%                   </div>
%     
%                   <div className='player-layer mouse-show'>
%                       <div id='player-controls' className='player-controls'>
%                           <div className='player-controls-row'>
%                               <RangeBar value={this.processor.timeProgress} handle_change={this.setTime} style={{ 'margin-top': '5px', 'margin-bottom': '5px' }} />
%                           </div>
%                           <div className='player-controls-row'>
%                               <div onClick={this.playback} className="player-button player-button-play">
%                                   {this.state.playbackIcon}
%                               </div>
%                               <VolumeSlider volume={this.state.volume} volumeHandler={this.setVolume} toggleMute={this.changeMute} />
%                               <TimeIndicator time={this.processor.time} duration={this.processor.duration} />
%                               <div className='player-button' onClick={this.togglePlaylist}>
%                                   <MdQueue />
%                               </div>
%                               <div id='fullscreen-btn' onClick={this.fullscreen} className="player-button player-button-fullscreen">
%                                   <MdFullscreen />
%                               </div>
%                           </div>
%                       </div>
%                   </div>
%                   <Notifications />
%                   <PlayList processor={this.processor} visibility={this.state.playlist} playlistLogic={this.props.playlistLogic} libraryLogic={this.props.libraryLogic} %toogleVideoChooser={this.toogleVideoChooser} />
%                   {this.state.showChat &&
%                       <div className='player-layer'>
%                           <Chat hide={this.toogleChat}/>
%                       </div>
%                   }
%               </div>
%           );
%       }
%    }
%     
%    export default Player;
%
%    class PlayerBackend {
% constructor(video) {
%     this._video = video;
%     this._preActions = {};
%     this._actions = {
%         'changePlayback': this.changePlayback,
%         'setTime': this.setTime,
%         'setVolume': this.setVolume,
%         'changeMute': this.changeMute,
%         'setSrc': this.setSource
%     }
% }
% 
% set video(value) {
%     this._video = value;
%     this._video.addEventListener('error', (e) => { console.error('error', e) });
%     this._video.addEventListener('waiting', (e) => { console.error('waiting', e) });
%     this._video.addEventListener('stalled', (e) => { console.error('stalled', e) });
% }
% 
% get video() {
%     return this._video;
% }
% 
% addPreAction = (value, action) => {
%     if (this._preActions[action] === undefined) {
%         this._preActions[action] = []
%     }
%     this._preActions[action].push(value);
% }
% 
% resetPreActions() {
%     this._preActions = {}
% }
% 
% resetPostActions() {
%     this._preActions = {}
% }
% 
% // Playback
% _play = () => {
%     this._video.play().catch((e) => console.error('playback', e));
% }
% 
% _pause = () => {
%     this._video.pause();
% }
% 
% get paused() {
%     return this._video.paused;
% }
% 
% changePlayback = (paused) => {
%     if (paused !== undefined) {
%         paused ? this._play() : this._pause();
%     } else {
%         this.paused ?  this._play() : this._pause();
%     }
% }
% 
% // Volume
% set volume(value) {
%     this._video.volume = value;
% }
% 
% setVolume = (value) => this._video.volume = value;
% 
% get volume() {
%     return this._video.volume;
% }
% 
% get muted() {
%     return this._video.muted;
% }
% 
% changeMute = () => {
%     this._video.muted = !this._video.muted;
% }
% 
% // Time
% setTime = (value) => this._video.currentTime = value;
%  set time(value) {
%     this._video.currentTime = value;
% }
% 
% setTime = (value) => this._video.currentTime = value;
% 
% get time() {
%     return this._video ? this._video.currentTime || 0 : 0;
% }
% 
% get timeProgress() {
%     return this._video ? this._video.currentTime / this._video.duration || 0 : 0;
% }
% 
% get duration() {
%     return this._video ? this._video.duration || 0 : 0;
% }
% 
% //  Src
% set source(value) {
%     this._video.src = value;
% }
% 
% setSource = (value) => this._video.src = value;
% 
% dispatch = (action, value) => {
%     let _preActions = this._preActions[action] || [];
%     const _actionWrapper = promiseWrapper(this._actions[action], value);
% 
%     let promise = new Promise(resolve => resolve());
%     for (const _preAction of _preActions) {
%         promise = promise.then(promiseWrapper(_preAction, value));
%     }
% 
%     promise.then(promiseWrapper(this._actions[action], value));
% }
%}
%
%changePlayback = (roomId, paused) => {
% let room_ref = this.db.collection('rooms').doc(roomId);
% room_ref.update({ paused })
% return room_ref.get().then(() => 'skip');
%}
% 
%listenPlayback = (roomId, dispatcher) => {
% return this.db.collection('rooms').doc(roomId).onSnapshot(snap => {
%   if (snap.data()) {
%     dispatcher.firebaseData.paused = snap.data().paused;
%     dispatcher.changePlayback(!snap.data().paused);
% 
%   }
% });
%}
% 
%getPlayback = (roomId, dispatcher) => {
% let roomRef = this.db.collection('rooms').doc(roomId);
% return roomRef.get().then(value => dispatcher.changePlayback(!value.data().paused));
%}
% 
%setTime = (roomId, time) => {
% let room_ref = this.db.collection('rooms').doc(roomId);
% room_ref.update({ time })
% return room_ref.get().then(() => 'skip');
%}
% 
%listenTime = (roomId, dispatcher) => {
% return this.db.collection('rooms').doc(roomId).onSnapshot(snap => {
%   if (snap.data()) {
%     if (dispatcher.firebaseData.time !== snap.data().time || dispatcher.firebaseData.src != snap.data().src) {
%       dispatcher.firebaseData.time = snap.data().time;
%       dispatcher.setTime(snap.data().time)
%     }
% 
%   }
% });
%}
% 
%getTime = (roomId, dispatcher) => {
% let roomRef = this.db.collection('rooms').doc(roomId);
% return roomRef.get().then(value => dispatcher.setTime(value.data().time || 0));
%}
% 
%listenSrc = (roomId, dispatcher) => {
% return this.db.collection('rooms').doc(roomId).onSnapshot(snap => {
%   if (snap.data()) {
%     if (dispatcher.firebaseData.src !== snap.data().src) {
%       dispatcher.firebaseData.src = snap.data().src;
%       dispatcher.setSource(snap.data().src)
%     }
%   }
% });
%}
% 
%setSrc = (roomId, src) => {
% let room_ref = this.db.collection('rooms').doc(roomId);
% let roomInfoRef = this.db.collection('roominfo').doc(roomId);
% room_ref.update({ src })
% roomInfoRef.update({ src });
% return room_ref.get().then(() => 'skip');
%}
% 
%listenPlaylist = (roomId, controller) => {
% let playlistRef = this.db.collection('playlists').doc(roomId);
% return playlistRef.onSnapshot(snap => {
%   if (snap.data()) {
%     controller(snap.data().videos)
%   }
% })
%}
% 
%addItemsToPlaylist = (playlistId, items) => {
% let playlistRef = this.db.collection('playlists').doc(playlistId);
% return playlistRef.update({ videos: firebase.firestore.FieldValue.arrayUnion(...items) });
%}
% 
%removeItemsFromPlaylist = (playlistId, items) => {
% let playlistRef = this.db.collection('playlists').doc(playlistId);
% playlistRef.update({
%   videos: firebase.firestore.FieldValue.arrayRemove(...items)
% })
%}
% 
%setPlaylist = (playlistId, playlist) => {
% let playlistRef = this.db.collection('playlists').doc(playlistId);
% return playlistRef.update({ videos: playlist });
%}
% 
%addUserToRoom = (roomId) => {
% let user = this.auth.currentUser;
% console.log('user', user)
% if (user) {
%   let statsRef = this.db.collection('stats').doc(roomId);
%   statsRef.update({
%     users: firebase.firestore.FieldValue.arrayUnion({ id: user.uid, status: null })
%   });
% }
%}
% 
%removeUserFromRoom = (roomId) => {
% let user = this.auth.currentUser;
% if (user) {
%   let statsRef = this.db.collection('stats').doc(roomId);
%   statsRef.update({
%     users: firebase.firestore.FieldValue.arrayRemove({ id: user.uid, status: null })
%   });
% }
%}
% 
%createRoom = (name, usePassword, password) => {
% if (!this.auth.currentUser.isAnonymous) {
%   return this.db.collection('roominfo').where('owner', '==', this.auth.currentUser.uid).get().then((querySnap) => {
%     if (querySnap.size < 1) {
%       return this.db.collection('roominfo').add({
%         name,
%         usePassword,
%         password,
%         users: [],
%         hidden: false,
%         src: '',
%         owner: this.auth.currentUser.uid,
%       }).then(docRef => {
%         this.db.collection('rooms').doc(docRef.id).set({ paused: true, src: '', time: 0, })
%         this.db.collection('messages').doc(docRef.id).set({ messages: [] });
%         this.db.collection('videos').doc(docRef.id).set({ videos: [] });
%       });
%     } else {
%       throw Error("You can't create more rooms")
%     }
%   })
% 
% }
%}
% 
%listenRooms = (controller) => {
% return this.db.collection('roominfo').onSnapshot(snap => {
%   let rooms = [];
%   snap.forEach(doc => {
%     rooms.push({ ...doc.data(), id: doc.id });
%   })
%   controller(rooms);
% });
%}
% 
%listenRoom = (roomId, controller) => {
% return this.db.collection('roominfo').doc(roomId).onSnapshot(snap => {
%   if (snap.data()) {
%     controller(snap.data());
%   }
% })
%}
% 
%getRoom = (roomId) => {
% return this.db.collection('roominfo').doc(roomId).get().then(doc => {
%   return doc.data();
% });
%}
% 
%getUserRooms = (userId) => {
% return this.db.collection('roominfo').where('owner', '==', userId || '').get().then((querySnap) => {
%   const rooms = []
%   querySnap.forEach(doc => {
%     rooms.push(doc.data());
%   })
%   return rooms;
% })
%}
% 
%enterRoom = (roomId, password) => {
% let docRef = this.db.collection('roominfo').doc(roomId)
% return docRef.get().then(doc => {
%   let result = true;
%   if (doc.data().usePassword && password !== doc.data().password) {
%     result = false;
%   }
%   return result;
% })
%}
% 
%findRoom = (query) => {
% return this.db.collection('roominfo').get().then(snap => {
%   let result = [];
% 
%   snap.forEach(docRef => {
%     if (docRef.data().name.includes(query)) {
%       result.push(docRef.data());
%     }
%   });
% 
%   return result;
% })
%}
% 
%listenChat = (roomId, controller) => {
% return this.db.collection('messages').doc(roomId).onSnapshot(snap => {
%   controller(snap.data().messages);
% });
%}
%
%class FirebasePlayer extends PureComponent {
%    constructor(props) {
%        super(props);
%        if (props.roomId) {
%            this.events = {
%                'changePlayback': this.firebasePlayback,
%                'setTime': this.firebaseTime,
%                'setSrc': this.firebaseSource,
%            }
%            this.setUp = [this.setUpFirebaseData, this.firebaseListenSource, this.firebaseListenPlayback, this.firebaseListenTime]
%            this.libraryLogic = {
%                'getLibraryItem': this.firebaseGetLibraryItem
%            }
%            this.playlistLogic = {
%                'listenPlaylist': this.firebaseListenPlaylist,
%                'addItems': this.firebaseAddItemsToPlaylist,
%                'removeItems': this.firebaseRemoveItemsFromPlaylist,
%                'setPlaylist': this.firebaseSetPlaylist,
%            }
%        }
%    }
%
%    componentDidMount() {
%        if (this.props.roomId) {
%            this.props.firebase.sign_in_anon().then(() => {
%                this.props.firebase.addUserToRoom(this.props.roomId);
%            })
%            window.addEventListener('beforeunload', () => this.props.firebase.removeUserFromRoom(this.props.roomId));
%
%        }
%    }
%
%    componentWillMount() {
%        if (this.props.roomId) {
%            window.removeEventListener('beforeunload', () => this.props.firebase.removeUserFromRoom(this.props.roomId));
%            this.props.firebase.removeUserFromRoom(this.props.roomId);
%
%        }
%    }
%
%    firebaseSetPlaylist = (playlist) => {
%        return this.props.firebase.setPlaylist(this.props.roomId, playlist);
%    }
%
%    firebaseRemoveItemsFromPlaylist = (items) => {
%        return this.props.firebase.removeItemsFromPlaylist(this.props.roomId, items);
%    }
%
%    firebasePlayback = (value) => {
%        return this.props.firebase.changePlayback(this.props.roomId, !value)
%    }
%
%    firebaseListenPlayback = (dispatcher) => {
%        return this.props.firebase.listenPlayback(this.props.roomId, dispatcher);
%    }
%
%    fetchPlayback = (dispatcher) => {
%        return this.props.firebase.getPlayback(this.props.roomId, dispatcher);
%    }
%
%    firebaseTime = (value) => {
%        return this.props.firebase.setTime(this.props.roomId, value)
%    }
%
%    firebaseListenTime = (dispatcher) => {
%        return this.props.firebase.listenTime(this.props.roomId, dispatcher);
%    }
%
%    setUpFirebaseData = (dispatcher) => {
%        dispatcher.firebaseData = {}
%    }
%
%    firebaseSource = (value) => {
%        return this.props.firebase.setSrc(this.props.roomId, value);
%    }
%
%    firebaseListenSource = (dispatcher) => {
%        return this.props.firebase.listenSrc(this.props.roomId, dispatcher);
%    }
%
%    firebaseGetLibraryItem = (id) => {
%        return this.props.firebase.getLibraryItem(id).then(value => value)
%    }
%
%    firebaseListenPlaylist = (controller) => {
%        return this.props.firebase.listenPlaylist(this.props.roomId, controller)
%    }
%
%    firebaseAddItemsToPlaylist = (items) => {
%        return this.props.firebase.addItemsToPlaylist(this.props.roomId, items)
%    }
%
%    render() {
%        return (
%            <div className='f-player'>
%                <Player events={this.events} externalSetUp={this.setUp} libraryLogic={this.libraryLogic} playlistLogic={this.playlistLogic} />
%            </div>
%        )
%    }
%}
%\end{lstlisting}
%